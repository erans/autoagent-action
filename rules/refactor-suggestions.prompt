Analyze the code for refactoring opportunities and code smells.

## Analysis Strategy

**Primary Focus**: Start by analyzing the changed files specified in the analysis scope. These files are your main target for refactoring suggestions.

**Extended Analysis**: When you identify patterns, duplications, or relationships that span beyond the changed files, you can:
- Use `grep` or `rg` commands to search for similar patterns across the codebase
- Use `ast-grep` for structural code pattern matching
- Examine related files that interact with the changed code
- Look for opportunities where changes in the modified files could benefit from refactoring in related files

**Prioritization**: Always prioritize refactoring suggestions for the changed files first, then mention related files as additional opportunities.

Focus on the following areas:

## Code Smells to Identify

### Long Methods/Functions
- Methods longer than 20-30 lines
- Functions with too many parameters (more than 3-4)
- Methods with high cyclomatic complexity

### Large Classes
- Classes with too many responsibilities
- Classes with too many methods or fields
- God classes that do everything

### Duplicate Code
- Copy-paste programming
- Similar logic repeated in multiple places
- Opportunities for extraction into common methods
- **Extended Search**: Use `grep` or `rg` to find similar code patterns across the entire codebase
- **Structure Analysis**: Use `ast-grep` to find structurally similar code blocks

### Dead Code
- Unused variables, methods, or classes
- Commented-out code that should be removed
- Unreachable code paths

### Poor Naming
- Variables with unclear names (a, b, temp, data)
- Methods that don't clearly describe what they do
- Classes with vague or misleading names

### Long Parameter Lists
- Methods with many parameters
- Opportunities to use parameter objects
- Boolean parameters that could be enums

### Data Clumps
- Groups of data that always appear together
- Opportunities to create data structures or classes

### Primitive Obsession
- Overuse of primitive types instead of domain objects
- Magic numbers and strings that should be constants

### Switch Statements
- Long switch/if-else chains
- Opportunities for polymorphism or strategy pattern

### Comments
- Code that needs comments to be understood
- Outdated or misleading comments
- Commented-out code

## Analysis Tools Available

When expanding beyond the changed files, use these commands:
- `grep -r "pattern" .` or `rg "pattern"` for text-based searches
- `ast-grep --pattern "$pattern"` for structural code matching
- `find . -name "*.ext" | head -10` to discover related files
- File reading tools to examine related code when patterns are found

## Refactoring Suggestions

**IMPORTANT: Only provide the final analysis results. Do not show your thinking process, intermediate steps, or work-in-progress.**

**Analysis Flow**:
1. Start with the changed files as your primary focus
2. When you find patterns or duplications, search for similar occurrences across the codebase
3. Prioritize refactoring suggestions by impact: changed files first, then related opportunities

For each issue found, provide:
- **Location**: File and line number
- **Issue Type**: Specific code smell or refactoring opportunity
- **Current Code**: Brief excerpt showing the problem
- **Suggested Refactoring**: Specific refactoring technique to apply
- **Benefits**: Why this refactoring would improve the code
- **Priority**: High/Medium/Low based on impact

## Refactoring Techniques to Suggest
- Extract Method
- Extract Class
- Move Method
- Replace Conditional with Polymorphism
- Introduce Parameter Object
- Replace Magic Number with Symbolic Constant
- Remove Duplicate Code
- Split Large Method
- Replace Inheritance with Delegation
- Introduce Null Object

If the code is already well-refactored, acknowledge the good practices and clean code patterns being used.

**Output Format**: Provide a concise, actionable summary focused on the most impactful refactoring opportunities only.
